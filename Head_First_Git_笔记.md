# Head First Git 笔记

## 第一章 入门   

### 1.git仓库初始化

``` git init``` 

初始化git仓库，该路径下将生成一个.git隐藏文件夹，表示git存储库，存储与项目有关的所有内容，包括提交（commit）、项目历史、配置文件等。

## 第二章 分支

### 2.git配置-记录个人信息

``` git config --global user.name "XXX" ```  告诉git你的名字
``` git config --global user.email "XXX@xxx.com"  ```  告诉git你的email

### 3.向git存储库增加文件

``` git add XXX.md```  将修改增加到**索引（暂存区）**   
``` git commit -m "提交说明" ```   将修改提交至**对象数据库**

### 4.git状态查看

``` git status ```   安全命令，需要在正确的目录中使用此命令，建议运行任何命令前先运行此命令。

### 5.git分支

``` git branch ``` 后面不带参数列出存储库中的所有分支，并标记目前所在分支。

``` git branch XXX（分支名) ``` 新建分支（分支名：XXX）

``` git switch XXX（分支名）``` 切换分支

``` git switch -c（或--create） XXX ``` 新建并切换到新建的分支

##### 每次切换分支时，Git会重写工作目录。如果在编辑器中有打开的文件，需要在编辑器中刷新文件，或者重写打开项目。

### 6.合并分支（merge）

将B分支上的内容合并到A分支上：

* 1.先切换到A分支上 ``` git switch 分支A ```
* 2.在A分支上执行命令 ``` git merge 分支B ```

以上，即可成功完成分支合并。


##### Tip：可以通过 ```git <command> --help ``` 打开命令的帮助页面，查看命令用法。
##### ```git <command> -h ``` 帮助命令的简化版
##### 快进合并(fast-forward)：master分支上没有新的提交，其他分支合并上来的时候就可以直接快进合并。

### 7.git创建提交/合并时的文本编辑器

Git的默认编辑器是Vim，如果想要将默认编辑器更换为Visual Studio Code，可以在终端输入下面的代码：

* 1.先在vscode中使用 command + shift + p，输入install，选择执行install 'code' command in PATH。

* 2.``` git config --global core.editor "code -w(或--wait)" ```

设置不同的编辑器时，更改"code -w"这一参数即可（搜索“如何设置XXX作为Git编辑器”，查看编辑器代码）。

git进行提交时，只输入``` git commit ```不带-m参数即可打开编辑器

### 8.冲突

两个分支对同一个文件的同一行都做了变更就会产生冲突，冲突在合并的文件中的形式：

```  
<<<<<<< HEAD                     // HEAD表示你所在的分支
I love branches                  // 此分支上的变更

=======                          // 分隔两个分支的分界符

branches rock!!                  // 另一个分支上的变更
>>>>>>> feat-a                   // 另一个分支的名字
```

在编辑器中解决完冲突，然后使用 ``` git add XXX文件、git commit ``` 完成最终的冲突合并。

### 9.删除分支

**已经完成合并**的特性分支可以删除，不能删除你所在的那个分支，要删除某个分支时要确保已经切换到了其他分支。

* 1.确认不在要删除的分支上：   

    - ``` git branch ```
* 2.删除分支  

    - ``` git branch -d XXX分支 ```

删除完成后git会返回删除分支上的最后一个提交的ID，如果不小心删除了错误的分支，就可以基于这个提交ID重新创建分支：   
``` git branch <branch-name> <base-commit-id> ```   

删除**未合并的分支**时git会提示错误，并拒绝删除可以使用强制删除：   
``` git branch -D XXX分支 ``` 


## 第三章 调查

### 10.查看提交历史

``` git log ``` 命令可以列出当前分支中所有的提交，显示**提交ID、提交人信息、提交时间、提交消息**。

一些参数可以美化git log命令的输出：   
``` git log --abbrev-commit ``` 可以简化提交ID（HEAD指向你所在的提交）   
``` git log --pretty=oneline ``` 隐藏作者和日期信息   
``` git log --pretty=oneline --abbrev-commit ``` 短ID + 隐藏作者、日期信息   
``` git log --oneline --all --graph ``` 所有分支提交记录的图形化显示     

### 11.查看文件变更（git diff）
* 1.``` git diff ``` ：可以查找git中所有文件的差异。比较**索引（暂存区）**和**工作目录**中的文件差异。   

 - 1.比较时会将暂存区中的内容作为“老”版本，工作目录中的内容作为“新”版本——前旧后新。   
 - 2.git会显示一个文件中的所有差异，然后再显示下一个文件中的差异。   
 - 3.即使在一个文件中，git也会一次展示一个区，称为"hunk"，每个hunk由"@@"开头。

* 2.``` @@ -5,7 +5,7 @@ To leverage my language skills as Chief Communications Officer```

 - 1.在git中执行**git diff命令**时返回的第一行信息``` diff --git a/resume.md b/resume.md```中，a表示老版本，b表示新版本。   
 - 2.---作为前缀的行表示老版本，+++作为前缀的行表示新版本。
 - 3.**"-5,7"**表示暂存区/索引（旧版本）从第5行开始，共展示7行。**"+5,7"**表示工作目录（新版本），第5行开始，共展示7行。   

* 3.``` git diff --word-diff ```：显示各**单词**间的差异而不是各行的差异。
* 4.``` git diff --cached ``` ：比较**索引**和**对象数据库**中的文件差异——前旧后新。

### 12.比较分支
想将**add-skills**分支合并到**edit-per-scotty**分支上之前对比两个分支：  
``` git diff edit-per-scotty(目标) add-skills(源) ``` 合并方向：从源合并到目标

* 1.比较的是两个分支的末端(tip)。
* **git diff**可以只提供一个参数 ``` git diff add-skills ```，git会认为这是将分支与工作目录的当前状态做比较，这条语句相当于 ``` git diff add-skills <working-directory>```。

### 13.比较提交

``` git diff 38a7176(提交a的ID) 846c398(提交b的ID)```
在进行```git cherry-pick```（把提交从一个分支移动到另一个分支）时可以使用**比较提交**来协助。


## 第四章 改正你的错误
### 14.回退变更

* 1.撤销工作目录中的变更
``` git restore XXX文件```命令会用索引中的内容重写工作目录中的内容，效果和``` git add ```命令效果相反。 **git restore** <---> **git add**

 - git restore 可以接受一个或多个文件路径作为参数。因此，该命令可以单独回退或批量回退更改。

* 2.撤销索引中的变更

``` git restore --staged XXX文件 ``` 命令会用对象数据库中的内容重写索引中的内容，效果与``` git commit```命令效果相反。**git restore --staged** <---> **git commit**

### 15.从git存储库删除文件
``` git rm XXX文件 ``` 在工作目录和索引中删除以跟踪的文件，参数可以一个或多个。已经提交到对象数据库中的文件不会被删除。想在对象数据库中删除就需要提交这个变更。

* 如果没使用**git rm**而是直接从文件中删掉了某个文件，就必须运行**git add -u或--update**告诉Git要记录索引中所删除的文件名字。

### 16.重命名（或移动）文件
``` git mv file-a.md file-b.md ``` 将file-a.md文件重命名为file-b.md

* 与**git rm**类似**git mv**也是修改工作目录和索引中的内容。
* 与**git rm**类似，也可以自己在系统中对文件重命名，但是需要更新索引来反映新的文件名（**git add -u或--update**）。

### 17.修改提交消息(commit -m "修改这个消息")

* 首先，确保在正确的分支上；其次，工作目录要干净，即索引中没有未提交的变更。

``` git commit --amend -m "新的提交消息" ``` 修改当前分支上的最后一个提交。

### 18.重命名分支名称
* 先切换到想要修改的分支，然后执行语句 ``` git branch -m glamping-trip(新分支名) ```
* 不切换分支改名法，``` git branch -m camping-trip(旧分支名) glamping-trip(新分支名) ```


### 19.HEAD：记录分支的最后一个提交

* 1. HEAD~n:记录当前提交的第n个祖先，HEAD~1表示当前提交的第一个父提交，以此类推。
``` git diff HEAD~1 HEAD ```对比你所在的提交与前一个提交之间的差异。

* 2.当一个提交有不止一个父提交时，使用**^**区分，**HEAD^1**表示申请分支上的最后一个提交，**HEAD^2**表示被申请分支上的最后一个提交。

* 3.~和^可以配合使用，HEAD^1~2表示当前提交的第一个父提交的父提交的父提交。

* 4.对于一个合并提交，实际上HEAD~1就等同于HEAD^1。

### 20.撤销提交
``` git reset 3e3e847(提交ID)/HEAD~1 ``` 将HEAD和分支移到指定的提交   

``` git reset --soft 父提交``` 对象数据库中的内容回退到上一个提交，在工作目录和索引中仍然保留当前修改，只需要一个**git commit**就可以再次提交。

``` git reset --mixed(默认模式) 父提交 ``` 对象数据库和索引中的内容退回到上一个提交，工作目录中仍然保留当前修改，需要先**git add**再**git commit**才能再次提交。   

``` git reset --hard 父提交 ``` 对象数据库、索引和工作目录中的修改全部撤销，改动全部撤销，好像最新的提交从来没有发生过。

### 21.撤销提交的另一种方式
``` git revert B(要撤销的提交)/HEAD(撤销当前提交) ``` 不会擦除提交，会新曾一个提交，与想要撤销的提交中的修改全部相反，从而实现内容的回退。

## 第五章 远程工作

### 22.另一种建立Git存储库的方法：克隆
``` git clone <some-url> ``` 从远程(remote)克隆一个存储库，克隆步骤：

* 1.Git首先会在你运行git clone命令所在的那个目录中创建一个文件夹，这个文件夹与你克隆的存储库同名（除非你指定了一个不同的名字）。在这个文件夹中，它会创建一个.git文件夹。
* 2.然后它会从克隆的那个存储库复制完整的提交图，包括所有提交、分支和另外一些信息，把它们复制到刚创建的.git文件夹。
* 3.最后它使用git switch检出（check out）原存储库（克隆的那个存储库）中检出的同一个分支。

GitHub中的fork功能可以将别人的存储库复制到自己的库中。

### 23.在克隆的项目中，将本地变更推送到远程存储库
``` git push ``` 允许你将本地存储库中创建的所有新提交推送到远程存储库。

当本地存储库新建分支后，分支上的提交怎么推送到远程存储库呢？ 需要对git做一个配置：
``` git config --global push.default simple ``` 配置git的默认推送行为（全局配置，可在任意目录下执行）。git的默认推送参数就是simple，不用特别设置。   

``` git config --global push.default ``` 可以查看上面的配置是否生效，返回simple表示配置生效。

现在，使用``` git push ```即可安全地将本地存储库中的新提交推送到远程存储库。推送过程中git会提示你输入Username和Password（实际为personal access token）。推送完成后还可以去GitHub上查看推送是否成功。


### 24.查看远程存储库
``` git remote ``` 返回远程存储库的名字(一般是origin)。   
``` git remote -v(或--verebose) ``` 提供更详细的存储库名称(增加了远程存储库的地址)。   
我们在本地调用**git push**时，实际是在调用**git push origin**。

### 25.关于向远程存储库推送的一些问题(本地使用git commit --amend修改提交ID的问题)

当本地使用了``` git commit --amend -m "新提交消息" ``` 修改最近提交的提交信息时，会导致提交ID也随之变化，此时将本地提交推送到远程存储库时，Git就会拒绝推送，并提示你两次提交历史不一致。  

### 26.标准操作过程：分支
如果想做一些工作，应该从本地集成分支创建一个分支。你可以在本地创建的分支上增加提交，重命名分支，甚至可以删除分支：远程存储库完全不知道你所做的工作。对远程存储库而言，这些都不重要，你在本地创建的分支是私有的。只要最后将所有分支上的工作合并到一个集成分支上。   

### 27.合并分支：选项1（本地合并）
如果你想遵循合并到集成分支的标准模型，那么不需要做任何特殊工作。完成一个特性分支上的工作后，可以把它合并到一个集成分支（如master），然后再把master分支推送回远程存储库。   

当你的工作已经合并到集成分支后，就可以删除特性分支了。

### 28.推送本地分支
试图将一个分支推送到远程存储库时，Git会试着确定应该更新哪个远程分支。如果这个分支时全新的，Git在远程存储库中看不到对应的分支。他不知道怎么做，所以它会放弃。你要明确地告诉Git：要用你的克隆存储库中的提交更新远程存储库中的哪个分支(显示地指定分支名)：  
 
``` git push --set-upstream(或-u) origin local-branch(克隆存储库中的分支名)```    

* 为一个分支设置上游(upstream)目标时需要指定远程存储库名(origin)，因为Git允许你的本地存储库与多个远程存储库交互。你可以可以克隆一个存储库，但决定把变更推送到另一个存储库。
* 一旦为一个本地分支设置了上游目标，以后就不用再设置上游了。

### 29.合并分支：选项2（拉取请求）
GitHub和其他存储库管理器允许使用浏览器管理你的Git存储库，包括完成合并，这个特性叫做拉取请求(pull requests)。   

在GitHub上完成拉取请求后要尽快删除特性分支。目前已经知道如何使用各种git push命令用新提交或新分支更新远程存储库，后续将继续学习如何使用远程存储库中的变更同步本地存储库。   


## 第六章 团队协作
### 30.多个合作者
如果你要在远程存储库上与某个人协作，就要在GitHub上把他增加为一个合作者，这样他就可以把分支和提交推送到你的账户下的存储库。
   
* 1.点击"Setting"(设置)设置标签页。
* 2.点击左边的"Manage access"菜单项。
* 点击绿色的"Invite a collaborator"(邀请一个合作者)按钮。   

通过GitHub**用户名**或**email**可以搜索到GitHub用户。   

### 31.赶上远程存储库（git pull）
``` git pull ``` 命令可以用来追平远程存储库中的变更，用来检查远程存储库中的一个特定分支（你当前所在的分支）上是否出现了新的提交，用这些提交更新本地分支。

### 32.远程跟踪分支(origin)
当你克隆一个Git存储库时会发生什么：   

* 1.Git会创建必要的文件夹，将提交历史复制到你的本地.git目录中，最后切换到默认分支。
* 2.创建一组分支，这些分支与远程存储库中的分支同名，只不过分支名前面有远程存储库名（默认为origin）作为前缀。你的本地master分支、origin/master分支和远程存储库的master分支都指向同一个提交ID。

你克隆存储库时Git创建的这些分支（有远程存储库名前缀）称为**远程跟踪分支(remote tracking branches)**。   

### 33.远程跟踪分支存在的理由1：知道推送到哪里
当你完成某些Git操作时（如推送或拉取），利用远程跟踪分支。Git会告诉你：本地克隆存储库中的哪些分支与远程存储库中的分支关联。   
可以使用**git branch**命令询问Git分支关联情况：   
``` git branch -vv```    
返回查询结果:   
**master 1975528 [origin/master] add first FAQ**    

当在克隆存储库中新建了一个分支的时候，需要通过设置上游操作来建立远程跟踪分支：
``` git push --set-upstream origin feat-a(远程存储库中的分支名) ``` 之后Git就会知道如何将本地的一个分支与远程存储库中的相应分支关联起来。

### 34.获取远程跟踪分支(git fetch)
``` git fetch ``` 从远程存储库下载所有提交和分支。这个命令只更新**远程跟踪分支**而不影响本地分支。

### 35.远程跟踪分支存在的理由2：从远程存储库获取（所有）更新
``` git branch -a(--all) ``` 查看你的存储库中所有分支的列表，也就是说，本地分支和远程跟踪分支的完整列表。   

获取到远程存储库中的新的分之后使用``` git switch sangita-add-profile ``` 切换分支命令后就会自动建立本地存储副本，在分支上进行编辑修改操作了。   

### 36.远程跟踪分支存在的理由3：知道需要推送
远程跟踪分支是远程存储库的本地镜像，如果你在本地建立了新提交，Git就可以利用远程跟踪分支告诉你有什么变化。   

### 37.远程跟踪分支存在的理由4：准备推送
某个分支下的远程存储库中有了新提交，你的本地克隆也有了新提交，这个分支已经出现了分叉，当你使用**git push**时，Git会拒绝你的推送。   
如果你想要推送你的变更，就要通过远程跟踪分支：   

* 1.使用**git fetch**更新远程跟踪分支。
* 2.合并**远程跟踪分支(origin/master)**与**本地分支(master)**：``` git merge origin/master ```。
* 3.解决本地合并的冲突，然后再次推送(git push)。   

```git pull``` = ```git fetch``` + ```git merge```   
实际工作过程中尽量使用**git fetch**和**git merge**的组合，避免使用**git pull**，因为：

* 1. git fetch不会影响你的本地分支，可以随时执行此命令了解远程存储库的动态。   
* 2. 完成git fetch后可以检查你的git status来了解你的本地分支相对于他的远程跟踪分支的位置，然后决定你下一步要做什么。   

###38.特性分支的合并建议
在将特性分支合并到master之前最好将master上的工作合并到你的特性分支，这样就能避免在master上解决冲突，合并方式有两种：   

* 1.完成一个git fetch，并把origin/master合并到master。然后将master合并到你的特性分支。
* 2.完成一个git fetch，并把origin/master合并到你的特性分支。

当你与其他人合作时，一般更建议在GitHub上通过拉取请求完成合并，而非在本地克隆存储库上合并后再推送至远程存储库。   

###39.如何删除分支(本地分支 & 远程存储库分支)

* 1.先删除本地分支，再删除远程存储库上的分支   
  -可以只用branch命令并提供-d(或--delete)标志来删除本地分支。然后向远程存储库推送一个分支删除来删除远程存储库上的分支：   
``` git push -d(--delete) origin(远程存储库名) feat-a(要删除的分支名)```   

* 2.先删除远程存储库上的分支，再删除本地分支   
 -在远程存储库上完成删除分支后，使用```git fetch -p(--prune)```命令，会得到出现在远程存储库中的所有新分支和提交，**并清理不再有相应远程分支的所有远程跟踪分支**。余下的就是删除本地分支。